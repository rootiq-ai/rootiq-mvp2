#!/usr/bin/env python3
"""
Performance Testing for AI Observability RCA
This script uses Locust to perform load testing on the system.

Installation:
pip install locust

Usage:
# Run with Web UI
locust -f scripts/performance_test.py --host=http://localhost:8000

# Run headless
locust -f scripts/performance_test.py --host=http://localhost:8000 --users 10 --spawn-rate 2 --run-time 5m --headless

# Run specific test scenarios
locust -f scripts/performance_test.py AlertSubmissionUser --host=http://localhost:8000 --users 20 --spawn-rate 5 --run-time 10m
"""

import random
import json
import uuid
from datetime import datetime, timedelta
from locust import HttpUser, task, between, events

# Sample data for performance testing
MONITORING_SOURCES = ["prometheus", "grafana", "datadog", "newrelic", "zabbix"]
SEVERITIES = ["low", "medium", "high", "critical"]
ALERT_TYPES = ["logs", "metrics", "traces", "events"]
SERVICES = ["web-service", "api-gateway", "user-service", "payment-service", "database"]
HOSTS = ["web-01", "web-02", "api-01", "api-02", "db-master"]

class BaseAPIUser(HttpUser):
    """Base user class with common functionality"""
    
    def on_start(self):
        """Called when a user starts"""
        self.api_key = "test-api-key"  # If API key is required
        self.headers = {"Content-Type": "application/json"}
        
        # Test API health on start
        response = self.client.get("/api/health", headers=self.headers)
        if response.status_code != 200:
            print("⚠️ API health check failed!")
    
    def generate_alert_data(self):
        """Generate realistic alert data"""
        return {
            "alert_id": str(uuid.uuid4()),
            "source": random.choice(MONITORING_SOURCES),
            "severity": random.choice(SEVERITIES),
            "title": f"Test Alert - {random.choice(['CPU High', 'Memory Low', 'Service Down', 'Network Error'])}",
            "message": f"Performance test alert generated at {datetime.now().isoformat()}",
            "alert_type": random.choice(ALERT_TYPES),
            "description": "Generated by performance testing script",
            "raw_data": {
                "host": random.choice(HOSTS),
                "service": random.choice(SERVICES),
                "metric_value": random.uniform(0, 100),
                "threshold": random.uniform(50, 90),
                "test_alert": True,
                "timestamp": datetime.now().isoformat()
            },
            "alert_timestamp": datetime.now().isoformat()
        }

class AlertSubmissionUser(BaseAPIUser):
    """User that primarily submits alerts"""
    
    wait_time = between(1, 3)
    weight = 3  # Higher weight = more users of this type
    
    @task(5)
    def submit_alert(self):
        """Submit a new alert"""
        alert_data = self.generate_alert_data()
        
        with self.client.post(
            "/api/alerts/",
            json=alert_data,
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 201:
                response.success()
                # Store alert ID for later use
                if hasattr(self, 'created_alerts'):
                    self.created_alerts.append(response.json().get('alert_id'))
                else:
                    self.created_alerts = [response.json().get('alert_id')]
            else:
                response.failure(f"Failed to create alert: {response.status_code}")
    
    @task(2)
    def get_alerts(self):
        """Retrieve alerts with pagination"""
        params = {
            "limit": random.randint(10, 50),
            "offset": random.randint(0, 100)
        }
        
        # Sometimes add filters
        if random.random() < 0.3:
            params["severity"] = random.choice(SEVERITIES)
        
        if random.random() < 0.2:
            params["source"] = random.choice(MONITORING_SOURCES)
        
        with self.client.get(
            "/api/alerts/",
            params=params,
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to get alerts: {response.status_code}")
    
    @task(1)
    def get_alert_statistics(self):
        """Get alert statistics"""
        with self.client.get(
            "/api/alerts/stats/summary",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to get alert stats: {response.status_code}")

class RCAManagementUser(BaseAPIUser):
    """User that manages RCAs"""
    
    wait_time = between(2, 5)
    weight = 1  # Lower weight = fewer users of this type
    
    def on_start(self):
        super().on_start()
        self.rca_ids = []
        
        # Get some existing RCAs
        response = self.client.get("/api/rca/?limit=10", headers=self.headers)
        if response.status_code == 200:
            rcas = response.json()
            self.rca_ids = [rca['rca_id'] for rca in rcas]
    
    @task(3)
    def get_rcas(self):
        """Retrieve RCAs with filters"""
        params = {
            "limit": random.randint(10, 20),
            "offset": random.randint(0, 50)
        }
        
        # Add random filters
        if random.random() < 0.3:
            params["status"] = random.choice(["open", "in_progress", "closed"])
        
        if random.random() < 0.2:
            params["priority"] = random.choice(["low", "medium", "high", "critical"])
        
        with self.client.get(
            "/api/rca/",
            params=params,
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to get RCAs: {response.status_code}")
    
    @task(2)
    def get_rca_details(self):
        """Get specific RCA details"""
        if not self.rca_ids:
            return
        
        rca_id = random.choice(self.rca_ids)
        
        with self.client.get(
            f"/api/rca/{rca_id}",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            elif response.status_code == 404:
                # Remove non-existent RCA from list
                self.rca_ids.remove(rca_id)
                response.success()  # Don't count as failure
            else:
                response.failure(f"Failed to get RCA details: {response.status_code}")
    
    @task(1)
    def update_rca_status(self):
        """Update RCA status"""
        if not self.rca_ids:
            return
        
        rca_id = random.choice(self.rca_ids)
        new_status = random.choice(["open", "in_progress", "closed"])
        
        with self.client.put(
            f"/api/rca/{rca_id}/status",
            params={"status": new_status},
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            elif response.status_code == 404:
                self.rca_ids.remove(rca_id)
                response.success()  # Don't count as failure
            else:
                response.failure(f"Failed to update RCA status: {response.status_code}")
    
    @task(1)
    def submit_feedback(self):
        """Submit RCA feedback"""
        if not self.rca_ids:
            return
        
        rca_id = random.choice(self.rca_ids)
        feedback_data = {
            "is_accurate": random.choice([True, False]),
            "accuracy_rating": random.uniform(0.1, 1.0),
            "feedback_text": "Performance test feedback",
            "user_id": f"test_user_{random.randint(1, 100)}",
            "user_role": random.choice(["engineer", "manager", "analyst"])
        }
        
        with self.client.post(
            f"/api/rca/{rca_id}/feedback",
            json=feedback_data,
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            elif response.status_code == 404:
                self.rca_ids.remove(rca_id)
                response.success()  # Don't count as failure
            else:
                response.failure(f"Failed to submit feedback: {response.status_code}")
    
    @task(1)
    def get_rca_statistics(self):
        """Get RCA statistics"""
        with self.client.get(
            "/api/rca/stats/summary",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to get RCA stats: {response.status_code}")

class HealthCheckUser(BaseAPIUser):
    """User that performs health checks and monitoring"""
    
    wait_time = between(5, 15)
    weight = 1
    
    @task(3)
    def basic_health_check(self):
        """Basic health check"""
        with self.client.get(
            "/api/health",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Health check failed: {response.status_code}")
    
    @task(1)
    def detailed_health_check(self):
        """Detailed health check"""
        with self.client.get(
            "/api/health/detailed",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code in [200, 503]:  # 503 is acceptable for degraded state
                response.success()
            else:
                response.failure(f"Detailed health check failed: {response.status_code}")

class CorrelationTestUser(BaseAPIUser):
    """User that tests correlation functionality"""
    
    wait_time = between(3, 8)
    weight = 1
    
    @task(2)
    def get_correlation_groups(self):
        """Get correlation groups"""
        with self.client.get(
            "/api/alerts/correlations/groups?limit=20",
            headers=self.headers,
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Failed to get correlation groups: {response.status_code}")
    
    @task(1)
    def submit_correlated_alerts(self):
        """Submit alerts that should be correlated"""
        # Generate similar alerts
        base_data = self.generate_alert_data()
        common_host = base_data["raw_data"]["host"]
        common_service = base_data["raw_data"]["service"]
        
        # Create 2-3 similar alerts
        for i in range(random.randint(2, 3)):
            alert_data = self.generate_alert_data()
            alert_data["raw_data"]["host"] = common_host
            alert_data["raw_data"]["service"] = common_service
            alert_data["title"] = f"Correlated Alert {i+1} - Service Issue"
            alert_data["severity"] = "high"
            
            self.client.post("/api/alerts/", json=alert_data, headers=self.headers)

# Custom Locust events for reporting
@events.test_start.add_listener
def on_test_start(environment, **kwargs):
    print("🚀 Starting performance test...")
    print(f"Target host: {environment.host}")

@events.test_stop.add_listener  
def on_test_stop(environment, **kwargs):
    print("🏁 Performance test completed!")
    
    # Print summary
    stats = environment.stats
    print(f"\n📊 Test Summary:")
    print(f"Total requests: {stats.total.num_requests}")
    print(f"Failure rate: {stats.total.fail_ratio:.2%}")
    print(f"Average response time: {stats.total.avg_response_time:.2f}ms")
    print(f"95th percentile: {stats.total.get_response_time_percentile(0.95):.2f}ms")

# Stress test scenario
class StressTestUser(BaseAPIUser):
    """High-intensity user for stress testing"""
    
    wait_time = between(0.1, 0.5)  # Very short wait times
    weight = 2
    
    @task(10)
    def rapid_alert_submission(self):
        """Rapidly submit alerts"""
        alert_data = self.generate_alert_data()
        self.client.post("/api/alerts/", json=alert_data, headers=self.headers)
    
    @task(5)
    def rapid_alert_retrieval(self):
        """Rapidly retrieve alerts"""
        params = {"limit": 10, "offset": random.randint(0, 50)}
        self.client.get("/api/alerts/", params=params, headers=self.headers)
    
    @task(1)
    def concurrent_health_checks(self):
        """Concurrent health checks"""
        self.client.get("/api/health", headers=self.headers)

# Load test profiles
class LightLoadUser(BaseAPIUser):
    """Light load user for sustained testing"""
    wait_time = between(5, 15)
    
    @task
    def mixed_operations(self):
        """Mix of operations with realistic timing"""
        # Random operation
        operation = random.choice([
            "submit_alert", "get_alerts", "health_check", "get_stats"
        ])
        
        if operation == "submit_alert":
            alert_data = self.generate_alert_data()
            self.client.post("/api/alerts/", json=alert_data, headers=self.headers)
        elif operation == "get_alerts":
            self.client.get("/api/alerts/?limit=20", headers=self.headers)
        elif operation == "health_check":
            self.client.get("/api/health", headers=self.headers)
        elif operation == "get_stats":
            self.client.get("/api/alerts/stats/summary", headers=self.headers)

# Performance test scenarios
class PerformanceTestScenarios:
    """Collection of performance test scenarios"""
    
    @staticmethod
    def baseline_test():
        """Baseline performance test"""
        return {
            "users": 10,
            "spawn_rate": 2,
            "run_time": "5m",
            "user_classes": [AlertSubmissionUser, RCAManagementUser]
        }
    
    @staticmethod
    def load_test():
        """Standard load test"""
        return {
            "users": 50,
            "spawn_rate": 5,
            "run_time": "15m",
            "user_classes": [AlertSubmissionUser, RCAManagementUser, HealthCheckUser]
        }
    
    @staticmethod
    def stress_test():
        """Stress test with high load"""
        return {
            "users": 200,
            "spawn_rate": 20,
            "run_time": "10m",
            "user_classes": [StressTestUser]
        }
    
    @staticmethod
    def spike_test():
        """Spike test with sudden load increase"""
        return {
            "users": 100,
            "spawn_rate": 50,
            "run_time": "5m",
            "user_classes": [AlertSubmissionUser, StressTestUser]
        }
    
    @staticmethod
    def endurance_test():
        """Long-running endurance test"""
        return {
            "users": 25,
            "spawn_rate": 5,
            "run_time": "60m",
            "user_classes": [LightLoadUser, HealthCheckUser]
        }

if __name__ == "__main__":
    print("""
Performance Testing for AI Observability RCA

Available user classes:
- AlertSubmissionUser: Submits and retrieves alerts
- RCAManagementUser: Manages RCA lifecycle
- HealthCheckUser: Monitors system health
- CorrelationTestUser: Tests alert correlation
- StressTestUser: High-intensity operations
- LightLoadUser: Sustained light operations

Usage examples:
1. Basic test:
   locust -f performance_test.py --host=http://localhost:8000

2. Headless load test:
   locust -f performance_test.py --host=http://localhost:8000 --users 50 --spawn-rate 5 --run-time 10m --headless

3. Specific user class:
   locust -f performance_test.py AlertSubmissionUser --host=http://localhost:8000 --users 20 --spawn-rate 5

4. Stress test:
   locust -f performance_test.py StressTestUser --host=http://localhost:8000 --users 100 --spawn-rate 20 --run-time 5m --headless
""")
